defmodule MqttHandler do
  require Logger
  use Tortoise.Handler

  def init(args) do
    %{seen: %{hosts: MapSet.new()}, args: args} |> reply_ok()
  end

  @doc """
    Invokved when the MQTT client connection status changes

    The first parameter will be either :up or :down to indicate
    the status.
  """
  def connection(:up, %{args: args} = s) do
    actions = get_in(args, [:next_actions, :connected]) |> List.wrap()

    reply_ok_next_action(actions, s)
  end

  def connection(:down, s) do
    reply_ok(s)
  end

  def connection(:terminated, s) do
    reply_ok(s)
  end

  # (1 of 2) ignore readings since they are an echo back of what's generated by RuthSim
  def handle_message([_prefix, "r" | _rest], _payload, s), do: reply_ok(s)

  # (2 of 2) handle
  def handle_message([_env, <<"ruth."::binary, _::binary>>, dev_type, _mtime], packed, s) do
    alias RuthSim.InboundMsg

    packed
    |> Msgpax.unpack()
    |> atomize_keys()
    |> InboundMsg.process(dev_type)

    reply_ok(s)
  end

  def log_msg(topic, raw_payload) do
    payload = Msgpax.unpack(raw_payload)

    pretty("inbound msg:\ntopic: #{topic}\npayload:", payload) |> Logger.info()
  end

  def reply_ok(s) when is_map(s) do
    {:ok, s}
  end

  def reply_ok_next_action(actions, s) when is_list(actions) and is_map(s) do
    {:ok, s, actions}
  end

  def subscription(_status, _topic_filter, s) do
    # pretty("status: #{inspect(status)} topic: #{inspect(topic_filter)}", s) |> Logger.info()

    reply_ok(s)
  end

  def terminate(reason, _state) do
    # tortoise doesn't care about what you return from terminate/2,
    # that is in alignment with other behaviours that implement a
    # terminate-callback
    Logger.warn(["Tortoise terminate: ", inspect(reason)])
    :ok
  end

  def pretty(msg, x) do
    ["#{msg}", "\n", inspect(x, pretty: true), "\n"]
  end

  defp atomize_keys({:ok, m}) when is_map(m) do
    {:ok, atomize_keys(m)}
  end

  defp atomize_keys({:error, _m} = passthrough), do: passthrough

  # don't attempt to atomize structs
  defp atomize_keys(m) when is_map(m) do
    m
    |> Enum.map(fn {k, v} -> {String.to_atom(k), atomize_keys(v)} end)
    |> Enum.into(%{})
  end

  # Walk the list and atomize the keys of
  # of any map members
  defp atomize_keys([head | rest]) do
    [atomize_keys(head) | atomize_keys(rest)]
  end

  # (3 of 3) just return the value when it's not a map
  defp atomize_keys(v), do: v
end
